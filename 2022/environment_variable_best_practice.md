tag: infrastructure, programming

# 環境変数のベストプラクティス

### １つの環境変数が1つの役割を持つ

```js
// Bad
if (process.env.NODE_ENV === 'production') {
  featureA();
}

// Good
if (process.env.ENABLE_FEATURE_A === 'true') {
  featureA();
}
```

`NODE_ENV=production` といった環境の名称を示す環境変数によって定数の値を切り替えたり、処理を分岐したりすることはアンチパターンだと考えています。
このようなコードがある場合、その環境変数がどのような振る舞いをするかが明示的ではなく、暗黙的な知識が必要となってしまいます。例えば、新しい環境を作ろうとした場合に、 `NODE_ENV` の値を新しく定義したものの、 `NODE_ENV` に応じて振る舞いを変えているコードがあった場合、それに気づかずにバグを生じてしまうリスクがあります。

環境変数を使って処理を分岐している場合、ユニットテストで分岐処理がカバーしにくいという点もあります。

```js
// Bad
if (process.env.NODE_ENV === 'production') {
  request('https://example.com');
} else {
  request('https://example.net');
}

// Good
request(process.env.EXAMPLE_URL);
```

上記の例では、Goodの場合はどのような環境でも共通のロジックを通り、定数部分だけが置き換わっているのに対し、Badの場合は `request('https://example.com');` というロジック自体が本番環境で初めて実行されることになるため、ランタイムエラーを生じるリスクが上がります。
上記の例のように単純な処理であるうちはまだ良いのですが、将来的に `if (process.env.NODE_ENV === 'production')` 内の処理が複雑化する可能性があり、この部分のロジックがユニットテスト等でカバーできないという点がネックとなります。

また、別のメリットとして、特定のテストで一部の振る舞いだけを変えたい場合に、環境変数を変えるだけで他の挙動に影響なくその振る舞いを変えられることが挙げられます。筆者の経験としては、Kubernetes上の検証環境で、ネットワークの疎通がない場合の挙動を確かめたい時に、 `kubectl set env` で特定の環境変数の値を変えるだけで実現できたことがありました。

### 必須の環境変数は必ずプログラム起動時にバリデーションを行う

```js
for (const requiredEnvName of ['FOO', 'BAR', 'BAZ']) {
  if (!process.env[requiredEnvName]) {
    throw new Error(`${requiredEnvName} is not defined`);
  }
}
```

環境変数はプログラム実行時に動的に読み込まれるため、環境変数の設定ミスがあるとプログラム実行時に問題が生じます。
ミスがあってもソフトウェアに影響を及ぼさずに発見できることが理想です。KuberentesのReadinessProbeのように、ヘルスチェックの応答によってアプリケーションへのルーティングが制御できる環境であれば、以下のようにして安全に環境変数をチェックできます。

- ヘルスチェックに応答する前に環境変数のバリデーションを行う
- バリデーションに失敗した場合、エラーメッセージを出力してアプリケーションを終了する

また、複数のファイルでバリデーションを実行しているとバリデーションの処理漏れやミスが生じやすいため、なるべくバリデーションの処理は1つのファイル内で行ったほうが良いでしょう。

Webフロントエンドのアプリケーションの場合、webpackなどでビルド時に環境変数を渡している箇所があれば、ビルドの前処理として環境変数のバリデーションを行い、バリデーションに失敗すればビルド自体も失敗させることで、事前にミスを検知することができます。

### 本番環境と開発環境で値が異なる環境変数を省略しない

```js
// Bad
const apiUrl = process.env.API_URL || 'https://api.example.com';

// Good
if (!process.env.API_URL) {
  throw new Error('API_URL is not defined');
}
const apiUrl = process.env.API_URL;
```

本番環境と開発環境で値が異なる環境変数に対し、省略した場合に "デフォルト値" が設定されるようにしてしまうと、本番環境で環境変数の設定ミスがあると障害につながるリスクがあります。
上の項目で記載したように、こうした値に対しては必ずバリデーションを行い、環境変数が渡されていなければプログラム起動時にアプリケーションを終了するようにしていると良いでしょう。

### 長くても明示的な名前をつける

環境変数はプログラム全体に影響する一種のグローバル変数と言えるため、曖昧な名前は混乱を招く原因になりえます。冗長になっても、どう利用されるかが明確となる名前をつけることが望ましいです。

```bash
# Bad, where is this `URL` used?
URL=https://api.example.com npm start

# Good
API_URL=https://api.example.com npm start
```

上の例では、 `https://api.example.com` に `api` が入っているので `API_URL` としなくてもAPIのURLであるのは明らかなように見えますが、環境によっては明示的でないURLが入力される可能性もありますし、ソースコード上では環境変数の中身は見えないため、プログラムの可読性も下げてしまいます。
